package main

import (
	"encoding/json"
	"fmt"
	"io/ioutil"
	"log"
	"net/http"
	"net/url"
	"strings"

	"github.com/tidwall/gjson"
)

// MalwareBazaar struct implementation
type MalwareBazaar struct {
	MalwareSource
}

// FindFile implementation for MalwareBazaar
// https://bazaar.abuse.ch/api/#query_hash
func (src *MalwareBazaar) FindFile(sample *Sample) {
	// default not found
	src.CanDownload = false
	src.HasFile = false

	// make request
	formData := url.Values{
		"query": {"get_info"},
		"hash":  {sample.UserHash},
	}

	resp, err := http.PostForm("https://mb-api.abuse.ch/api/v1/", formData)
	if err != nil {
		log.Println("Error when contacting MB: " + err.Error())
		return
	}
	defer resp.Body.Close()

	body, err := ioutil.ReadAll(resp.Body)
	if err != nil {
		log.Println("Failed to get bytes from MB response: " + err.Error())
		return
	}

	// parse json response
	var jsonDataRaw interface{}
	err = json.Unmarshal(body, &jsonDataRaw)
	if err != nil {
		log.Println("Error parsing JSON data from MB: " + err.Error())
	}
	var jsonData map[string]interface{} = jsonDataRaw.(map[string]interface{})

	// if the top-level key 'query_status' == 'ok', file exists
	// if the top-level key 'query_status' == 'hash_not_found', file doesn't exist
	queryStatus, ok := jsonData["query_status"]
	if !ok {
		log.Println("Failed to get query_status field in MB response")
		return
	}

	if queryStatus == "ok" {
		src.HasFile = true
		src.CanDownload = true

		// save hashes
		// since data is the same, it's ok to overwrite Sample members
		sha256 := strings.Trim(string(gjson.GetBytes(body, "data.0.sha256_hash").Raw), "\"")
		sha1 := strings.Trim(string(gjson.GetBytes(body, "data.0.sha1_hash").Raw), "\"")
		md5 := strings.Trim(string(gjson.GetBytes(body, "data.0.md5_hash").Raw), "\"")
		sample.MD5 = md5
		sample.SHA1 = sha1
		sample.SHA256 = sha256

		src.URL = fmt.Sprintf("https://bazaar.abuse.ch/sample/%v/", sha256)
	} else if queryStatus == "hash_not_found" {
		// hash not found
		src.CanDownload = false
	} else {
		log.Println("Got an unknown response from MB")
	}
}

// DownloadFile implementation for MalwareBazaar
// https://bazaar.abuse.ch/api/#download
func (src *MalwareBazaar) DownloadFile(sample Sample) bool {
	log.Println("Downloading from MB not yet supported")
	return false
}
